# 指针

我们已经看到比变量如何通过标识符作为内存单元被使用。使用这种方式我们就无需单选数据在内存中的具体地址，而只需在任何需要引用变量的地方使用这个标识符。

你计算机的内存可以被看作是一系列的内存单元，每个包含计算机控制的最小大小（一个字节）。这些单字节的内存单元是连续排列的，所以，在任何内存块内，每个单元的位置为前一个单元的位置加1。

这样，每个单元可以很容易的在内存中定位，因为其含有唯一的地址且所有的内存单元以连续的方式排列。例如，如果我们查找内存单元1776，我们直到其在1775和1777之间，在776后面的第1000个单元，在2776之前的1000个单元。

## 引用操作符（&）

一旦声明一个变量，需要的内存数量就会在一个特定的位置分配（内存地址）。我们一般不需要自己去确定变量在内存单元内的确切地址，这是有操作系统在运行时自动执行的。然而，有些情况下，我们可能需要知道在运行时变量的存储地址，从而对其关联的位置执行操作。

内存中存储变量的地址称做变量的引用，这个变量的引用可以通过在变量标识符前加上`&`符号来获取，这个符号被称做引用符号，可以在字面上翻译为“取地址”，例如：

```cpp
ted = &andy;
```

这会将`andy`的地址赋值给`ted`，因为在变量`andy`前加上了引用符号`&`，则这里就不再是变量本身的内容，而是其引用（即，其内存中的地址）。

假设`andy`在运行时的内存位置1776。数字（1776）仅仅是我们这里为了解释本教程中的一些概念而随意做的假设。但是，实际上在运行之前我们无法直到变量在内存中的确切地址。

考虑如下的代码片段：

```cpp
andy = 25;
fred = andy;
ted = &andy;
```

执行之后每个变量的值如下表所示：

```
                              andy
          +-----+-----+-----+----------+----+----+
          |     |     |     |   25|    |    |    |
          +-----+-----+-----+-----+----+----+----+
                        1775  1776  1777
                              + +        &
                <-------------+ +----------------->
           fred                                    ted
+------+-------+------+                +------+--------------+
|      |    25 |      |                |      |   1776|      |
+------+-------+------+                +------+-------+------+

```

首先，我们将25赋值给`andy`（一个我们假设内存地址为1776的变量）。

第二个表达式将变量`andy`的值（25）拷贝给`fred`。这是一个标准赋值操作，且之前已经执行过很多次了。

最后，第三个表达式没有将`andy`的值拷贝给`ted`，而是其引用（即，其地址，这里假设是1776）。原因是在第三个表达式中，`andy`变量前有引用操作符`&`，所以这里不再指代`andy`的值而是其引用（其在内存中的地址）。

存储其他变量引用的变量（如上例中的`ted`）被称做为指针。指针是C++语言中高级编程中普遍使用的非常强大的功能。接下来，我们看下如何使用和声明这类变量。

## 解引用运算符（*）

我们刚刚看到了存储其他变量引用的变量被称做指针。指针的含义就是“指向”它们所引用的对象。

使用指针，我们可以直接访问所指向的变量存储的值。要做到这个，只需要在指针变量前加上星号（*），其作为解引用操作符，可以在字面上翻译为“指向的值”。

因此，接如上的示例，如果写：

```cpp
beth = *ted;
```

(这样可以如此翻译：“beth等于ted所指向的值”)`beth`会获取值25，因为`ted`为1776，而1776指向的值为25。

```
           ted
+---+-------------+
|   |     1776|   |
+---+------+------+
           +-----------------+
                             |
                        +----+---+
                  1775  |   1776 | 1777
               +------+----------------+
               |      | |     25||     |
               +------+----------------+
                        |        |
                        +----+---+
                             +-----------------------+
                                                     |
                                         +---+-------v-----+
                                         |   |       25|   |
                                         +---+-------------+
                                                    beth

```

必须要区分`ted`指代值`1776`，而`*ted`（在变量前有星号*）指代存储在地址1776的值，在设立就是25。注意包括和不包括解引用符号的差异（如下提供了一个如何读出相关语句的注释）

```cpp
beth = ted;   // beth equal to ted ( 1776 )
beth = *ted;  // beth equal to value pointed by ted ( 25
```

注意引用符号和解引用符号之间的差异：

* `&`为引用符号，可以读做“取地址”
* `*`为解引用符号，可以读做“指向的值”

因此，其存在互补（或者相反）的含义。一个使用`&`引用的变量可以使用`*`解引用。

早前，我们使用如下两个赋值操作：

```cpp
andy = 25;
ted = &andy;
```

在这两个语句之后，所有如下的表达式结果都为true：

```cpp
andy == 25;
&andy == 1776;
ted == 1776;
*ted == 25;
```

第一句话非常明显，因为andy上的赋值操作为`andy=25`。第二句话使用引用符号`&`，其返回`andy`变量的地址，此处我们假设其值为1776。第三句因为第二句为true而显得非常明显，`ted`上的赋值操作为`ted = &andy`。第四句话，使用了解引用符号（*)，如我们所见，可以读做“指向的值”，`ted`所指向的值为25。

所以，在此之后，可以推测只要`ted`指向的地址不变，如下的表达式会一直为true：

```cpp
*ted == andy;
```

## 声明指针类型

因为指针可以直接指代其指向的值，有必要在声明中明确指针所要指向的具体数据类型。指向`char`和指向`int`或者`float`并不等同。

指针的声明格式如下：

```cpp
type * name;
```

这里`type`为指针要指向的值的数据类型。这个类型并不是指指针本身的类型！而是指针指向的值的类型。例如：

```cpp
int * number;
char * character;
float * greatnumber;
```

这是三个指针的声明。每个都指向不同的数据类型，但是实际上它们都是指针，且都占据同样大小的内存（指针占用的内存大小取决于具体的运行时平台）。然而，它们所指向的值并不占用同样的空间，也不是同样的类型。第一个指针指向一个`int`、第二个指向`char`以及最后一个指向`float`。因此，尽管，这三个例子中三个指针占用同样的内存，它们是不同的数据类型：分别为`int *`、`char *`以及`float *`，具体依据它们所指向的数据的类型。

要强调星号（`*`）来声明一个指针，仅仅意味着其为指针，不应该和之前的解引用符号混淆，因为解引用符号也是星号（`*`）。这两者只不过是具备同样符号的不同事物。

现在看一下这个代码：

```cpp
// my first pointer
#include <iostream>
using namespace std;

int main () {
  int firstvalue, secondvalue;
  int * mypointer;

  mypointer = &firstvalue;
  *mypointer = 10;
  mypointer = &secondvalue;
  *mypointer = 20;
  cout << "firstvalue is " << firstvalue << endl;
  cout << "secondvalue is " << secondvalue << endl;
  return 0;
}
```

注意，尽管我们没有直接给`firstvalue`和`secondvalue`赋值，都是通过`mypointer`间接设置值。如下为具体过程：

首先，使用引用符号`&`给`mypointer`赋值`firstvalue`的引用。随后，将10赋给`mypointer`指向的内存地址，因为此时其指向`firstvalue`的内存地址，因此实际上修改的是`firstvalue`的值。

为了展示在程序中指针可以指向不同的值，所以对`secondvalue`重复了如上的过程，并使用了同样的指针`mypointer`。

这里为更加复杂的示例：

```cpp
// more pointers
#include <iostream>
using namespace std;

int main() {
  int firstvale = 5, secondvalue = 15;
  int * p1, * p2;

  p1 = &firstvalue; // p1=firstvalue的地址
  p2 = &secondvalue; // p2=secondvalue的地址
  *p1 = 10; // p1指向的地址=10
  *p2 = *p1; // p2指向的地址=p1指向的地址
  p1 = p2; // p1 = p2 (拷贝指针)
  *p1 = 20 // p1指向的地址 = 20;

  cout << "firstvalue is " << firstvalue << endl;
  cout << "secondvalue is " << secondvalue << endl;

  return 0;
}
```

每行后面有怎么读出该行的注释：（`&`)符号为“取地址”，(`*`)符号为指向的地址。

注意指针`p1`和`p2`的表达式，二者都有或者没有解引用符号（`*`）。使用解引用符号的表达式的含义和不适用差别很大：当这个符号在指针名之前时，这个表达式表示的是指向的值，而当没有这个符号是，其表示的是指针本身（即，指针所指向的值的地址）。

另一个可能引起你的注意的是就是：

```cpp
int * p1, * p2;
```

这里声明了两个指针。注意每个指针的星号（`*`）符号，这样二者都具备类型`int*`(指向`int`的指针)。

否则，这里声明的第二个变量的类型为`int`（而不是`int*`），像这样：

```cpp
int * p1, p2;
```

`p1`确实是`int*`类型，但是`p2`为`int`类型（空格在这里没啥特殊的作用）。这是因为操作符前置规则。一般，只要记住每个指针前都放一个星号就够了。

## 指针和数组

数组的概念和指针非常类似。实际上，数组的标识符等同于其第一个元素的地址，而指针等同于第一个元素指向的地址，所以实际上它们是同一个概念。例如，假设如下的声明：

```cpp
int numbers [20];
int * p;
```

下面的赋值也是有效的：

```cpp
p = numbers;
```

在这之后，`p`和`number`则等同，且具备相同的属性。唯一的不同就是可以给`p`赋值其他的值，而`number`会一直指向20个`int`元素的第一个。因此，不同于普通指针`p`，`number`为数组，数组可以被看作是常量指针。因此，如下的赋值为无效的：

```cpp
numbers = p;
```

因为`numbers`为数组，所以其作为常量指针，而不能给常量重复赋值。

因为变量的特点，如下例子中的所有表达式包括数组都是有效的：

```cpp
// more pointers
#include <iostream>
using namespace std;

int main()
{
  int numbers[5];
  int * p;
  p = numbers, *p = 10;
  p++; *p = 20;
  p = &numbers[2]; *p = 30;
  p = numbers + 3; *p = 40;
  p = numbers; *(p + 4) = 50;
  for (int n = 0; n < 5; n++)
    cout << numbers[n] << ", ";

  return 0;
}
```

在数组那章中，多次使用中括号（`[]`）指定要获取数组中的哪个元素。这些中括号操作符`[]`也被看作是偏移操作符，是解引用操作符的一种。这些符号的解引用的方式和`*`号一致，也是解引用的地址上增加一个数。例如：

```cpp
a[5] = 0;
*(a + 5) = 0;
```

这两个表达式是等同的，如果`a`为变量或者`a`为数组都是有效的。

## 指针初始化

当声明指针时，我们想要明确指定要指向的变量：

```cpp
int number;
int *tommy = &number;
```

这段代码的行为等同于：

```cpp
int number;
int *tommy;
tommy = &number;
```

当指针初始化进行时，总是会给出指针指向的值的引用（tommy)，而不是被指向的值。必须考虑在声明指针时，星号（`*`）仅仅表明这是个指针，而不是解引用符号（尽管都使用同一个符号：`*`）。记住，一个符号有两个不同的功能。因此，必须要避免混淆：

```cpp
int number;
int *tommy;
*tommy = &number;
```

这段代码是错误的，仔细思考会发现这段代码在此处没有实际的意义。

对于数组的情况，编译器会允许这种特殊的情况，指针声明的同时来初始化常量指针指向的对象：

```cpp
const char * terry = "hello";
```

这种情况下，内存空间会包含`"hello"`，然后一个指针指向这段内存块的第一个字符，并将指针赋值给`terry`。

注意`terry`的值为具体的内存地址，而不是`h`或者`hello`。

`terry`指针指向一个字符序列，且可以被认为是数组（记住数组也如同常量指针）。例如，我们可以使用如下方式访问数组的第五个元素：

```cpp
*(terry+4)
terry[4]
```

两个表达式都返回`o`值（数组的第5个元素）。

## 数组算术

在数组上完成算数计算和在普通的整数类型上存在差异。首先，只有加和减可以用在它们身上，其他的在指针这边没有实际的意义。但是加和减依据指针指向的值的数据类型的大小存在不同的行为。

当看到不同的基本数据类型时，可以看到一些会比其他的占用更多或者更少的内存。例如，假设，在给定的机器上使用给定的编译器，`char`占用1个字节，`short`占用2个字节，`long`占用4个字节。

假设在这个编译器上定义了三个指针：

```cpp
char *mychar;
short *myshort;
long *mylong;
```

假设其指向内存地址，1000、2000、3000.

这样，如果写下如下代码：

```cpp
mychar++;
myshort++;
mylong++;
```

针对`mychar`，如你所想，为值1001。但`myshort`并不明显，其为值`2002`，`mylong`则为3004，而它们都制式自增了一次。原因在于，当给指针加1时，我们之际上是指向了其定义时的数据类型的下一个元素，因此指向的类型的字节数会被加到指针上。

这在给指针增加或者减少任何数值时都适用。如下等同于上面的代码：

```cpp
mychar = mychar + 1;
myshort = myshort + 1;
mylong = mylong + 1;
```

自增（`++`）和自减（`--`）运算符的优先级高于解引用运算符（`*`），因此如下表达式容易混淆：

```cpp
*p++;
```

因为`++`比`*`的优先级高，表达式等同于`*(p++)`。因此，其所做的就是增加`p`的值（所以现在其指向下一个元素），但是因为`++`作为整个表达式的后缀，此时其值指向原始的引用（在自增前指针指向的地址）。

注意和如下的不同：

```cpp
(*p)++;
```

这里，这个表达式指向将`p`指向的值增加1。`p`的值（指针本身）不会被更改（被更改的只是其所指向的值）。

如果这样写：

```cpp
*p++ = *q++;
```
因为`++`比`*`的优先级高，`p`和`q`走自增，但是因为自增符号作为后缀而不是前缀，`*p`和`*q`的值会增加了。等同于：

```cpp
*p = *q;
++p;
++q;
```

一般而言，推荐使用扩含`()`来避免意外的结果以及让代码更加易于理解。

## 指向指针的指针

C++允许指针指向指针。要是现在这个，需要在声明中对每个引用增加一个星号（`*`）。

```cpp
char a;
char * b;
char ** c;
a = 'z';
b = &a;
c = &b;
```

每个变量的值都写在了相应的内存单元中；在内存单元中存储的就是其在内存中相应的地址。

这个例子中的一个新鲜事物就是变量`c`，可以使用在三种不同的级别下，每个都对应不同的值：

* `c` 类型为 `char**`
* `*c` 类型为 `char*`
* `**c` 类型为 `char`，为实际的值。

## void指针

`void`类型的指针为一种特殊指针。在C++中，`void`表示没有类型，所以void指针为指向无类型值的指针（因此，其长度和解引用属性也都不确定）。

这可以让void指针指向任何数据类型，从整数到浮点到字符串。但是，也有很多局限性：其指向的值不能直接解引用（在逻辑上，因为解引用无法确定具体的类型），因此在解引用前必须要将地址转换为其他类型的指针。

一个使用方法就是作为函数参数传递：

```cpp
// increaser
#include <iostream>
using namespace std;

void increase(void* data, int psize)
{
  if (psize == sizeof(char))
  {
    char* pchar;
    pchar = (char*)data;
    ++(*pchar);
  }
  else if (psize == sizeof(int))
  {
    int *pint;
    pint = (int*)data;
    ++(*pint);
  }
}

int main()
{
  char a = 'x';
  int b = 1602;
  increase(&a, sizeof(a));
  increase(&b, sizeof(b));
  cout << a << ", " << b << endl;
  return 0;
}
```

`sizeof`为C++语言中计算其传入参数字节数的操作符。对于非动态数据类型，这个值是个常量。因此，例如，`sizeof(char)`为1，因为`char`类型为一个字节长度。

## 空指针

空指针为不指向任何有效引用或者内存地址的指针。这个值由将整数0类型转换到其他指针类型而得到。

```cpp
int * p;
p = 0;
```

不要将空指针和void指针混淆。空指针就是表明当前指针不指向任何值的指针，而void指针为不具有任何特定类型但可以指向任何值的特殊指针。一个指代的是指针本身存储的值，另一个指代的值指针指向的数据类型。

## 指向函数的指针

C++允许指针指向函数。这里的一个典型使用方法就是将函数作为参数传递给其他函数，因为不能直接传递解引用的形式。要声明指向函数的指针，在声明函数原型时需要在函数名使用括号`()`包裹且函数名前要有星号`*`：

```cpp
// pointer to functions
#include <iostream>
using namespace std;

int addition (int a, int b)
{
  return (a + b);
}

int substraction(int a, int b)
{
  return (a - b);
}

int operation(int x, int y, int (*functioncall)(int, int))
{
  int g;
  g = (*function)(x, y);
  return (g);
}

int main()
{
  int m, n;
  int (*minus)(int, int) = substraction;

  m = operation(7, 5, additon);
  n = operation(20, m, minus);
  cout << n;
  return 0;
}
```

这个例子中，`minus`为指向函数的指针，其含有两个`int`类型的参数。其赋值给函数`substraction`：

```cpp
int (*minus)(int, int) = substraction;
```

