# 会话和进程组

在Linux或者其他Unix系统中，用户通常会和相互之间有关联的进程组进行交互。尽管用户通常登录到终端并使用单个进程（shell，其中提供了命令行界面），但是用户最终会因为如下行为运行多个进程：

* 在后台运行进程
* 通过Job control来在交互任务见切换
* 启动多个相关的进程并通过管道连接
* 运行windowing系统，例如X Window System，从而运行打开多个终端窗口

要管理所有这些进程，系统内核需要将进程以一种较复杂的方式进程归类。这些归类组被称做会话和进程组。

## 会话

当用户退出系统时，内核需要终结用户正在运行的所有进程（否则，用户会留下大量的挂起进程等待输入）。为了简化任务，进程被组织成一个会话集合。会话的ID等于创建这个会话的进程PID，主要通过`setsid()`系统方法来完成。进程也被称做会话组的会话首进程。该进程的所有衍生进程都会是这个会话的成员，除非将其移除出去。 `setsid()`函数没有任何参数，直接返回会话ID。

```
#include <unistd.h>

pid_t setsid(void)
```

## 控制终端

每个会话都会绑定一个终端，在这个终端上会话中的进程会获得输入并输出内。终端可以是机器的本地控制台，通过串行线连接的终端、或者映射到X window的伪终端、或者通过网络连接。连接到会话的终端被称做控制终端（或者控制tty）。一个会话一次只能连接一个终端。

尽管会话的控制终端可以被更改，但是这通常是通过管理用户初始登录的进程来操作的。

## 进程组

Unix系统最初的一个设计目标就是让一些列简单的工具可以以复杂的方式一起使用（通过如管道这种机制）。大多数Linux的使用者会执行如下操作，就是这种使用哲学的实际例子：

```
ls |grep "^[aA].*\.gz"|more
```

另一个很早就加入到Unix的留下功能是任务控制。任务控制允许用户在离开或者做其他事的时候挂起当前的任务（也就是foreground任务）。当挂起的任务是多个共同工作的任务的进程队列，系统需要追踪哪些任务在被挂起。进程组让操作系统能够追踪哪些进程是一起工作的，所以能够通过任务控制来管理这些进程。

进程通过`setpgid()`来追加到进程组中。

```
int setpgid(pid_t pid, pid_t pgid);
```

pid为要归组到新的进程组的进程ID（可以用0表示当前的进程）。pgid为相应的进程组ID，如果为0表示进程一年更改被追加到一个新的进程组，这个进程组的pgid和该进程的pid相等。如同会话，进程组组长为pid等于进程组ID的那个进程。

如何使用`setpgid()`会有点复杂：

1. 进程可能要设置其本身或者其子进程的进程组。但是不能更改系统中其他进程的进程组，即使进程以root的权限执行`setpgid`
2. 会话首进程不能更改其自身的进程组
3. 不同会话的进程之间不能相互移动，换句话说进程组中所有的进程必须属于同一个会话。

`setpgid()`调用将执行的进程归属到其自身的进程组和会话中。这可以确保不同会话不会包含属于同一个进程组的进程。

当连接的终端断开后，内核发送信号（SIGHUP)给会话的首进程，该会话包含终端的foreground进程组，通常是一个shell。这可以让shell无条件的终止用户的进程，通知进程用户已经退出（通过SIGHUP信号），或者通过其他的动作。尽管这个设置看起来复杂，其让会话组的组长进程来决定如何处理终端关闭的问题，而不是交给内核来处理。这让系统管理员可控制账户策略。

通过`getpgid()`和`getpgrp()`可以确定进程组。

```
pid_t getpgid(pid_t pid)
```

返回进程pid的pgid。如果pid为0，则返回当前进程的pgid。执行这个方法无需特殊权限；任何进程可以获取其他进程所属的进程组。

```
pid_t getpgrp(void)
```

返回当前进程的pgid。

## 孤立进程组

当会话结束时进程如何终止是非常复杂的机制。思考一下一个含有多个进程组的会话。会话运行在终端上，系统shell即为会话的首进程。

当会话的首进程（shell）退出时，进程组就会处于不确定的情形下。如果这些进程还在运行，则他们不能再使用stdin和stdout，因为终端已经被关闭了。如果他们被挂起了，则他们也许永远不会再次运行，因为用户不太能再次启动他们，同时永远不会被运行也意味着不会被终结。

这中情况下，进程组也被称做是孤立进程组。

尽管定义很复杂，但是概念很简单。如果进程组被挂起，且没有一个进程来告知其继续运行，则这个进程组为孤立的。

当shell退出，其子程序成为了init的子程序，但是保持在其原始的会话中。假设会话中所有的程序为shell的衍生，则该会话中所有的进程组被孤立。

当进程组被孤立时，进程组中的每个进程都会被发送SIGHUP信号，通常会终结进程。那些不接受SIGHUP信号的，会被发送SIGCONT信号，这会唤起挂起的进程。这个序列会终止大多数的进程并确保其他的进程可以继续运行（摆脱挂起的状态）。

一旦进程被孤立，则会强制从控制终端中剔除（让新的用户可以使用这个终端）。如果程序继续尝试访问终端，这些尝试会导致错误，错误码为EIO。进程保持在同一个会话中，其会话ID不会被用于新的进程ID，直到会话中所有的程序都退出。

